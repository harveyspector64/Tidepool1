<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>POLYP - Tide Pool Symphony</title>
<style>
body {
   margin: 0;
   padding: 0;
   overflow: hidden;
   background: #000;
   touch-action: none;
   -webkit-touch-callout: none;
   -webkit-user-select: none;
   user-select: none;
}
canvas {
   display: block;
   cursor: crosshair;
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/*
MIT License - POLYP: Tide Pool Anemone Life Sim
Deploy via GitHub Pages: Create repo, add this as index.html, enable Pages in Settings
*/

// Vector math utility
class Vec {
   constructor(x = 0, y = 0) {
       this.x = x;
       this.y = y;
   }
   
   add(v) { return new Vec(this.x + v.x, this.y + v.y); }
   sub(v) { return new Vec(this.x - v.x, this.y - v.y); }
   mul(s) { return new Vec(this.x * s, this.y * s); }
   div(s) { return new Vec(this.x / s, this.y / s); }
   dot(v) { return this.x * v.x + this.y * v.y; }
   len() { return Math.sqrt(this.x * this.x + this.y * this.y); }
   len2() { return this.x * this.x + this.y * this.y; }
   norm() { const l = this.len(); return l > 0 ? this.div(l) : new Vec(); }
   dist(v) { return this.sub(v).len(); }
   lerp(v, t) { return this.add(v.sub(this).mul(t)); }
   rotate(a) {
       const c = Math.cos(a), s = Math.sin(a);
       return new Vec(this.x * c - this.y * s, this.x * s + this.y * c);
   }
}

// Audio synthesis engine
class AudioBus {
   constructor() {
       this.ctx = null;
       this.masterGain = null;
       this.droneBass = null;
       this.droneFilter = null;
       
       try {
           this.ctx = new (window.AudioContext || window.webkitAudioContext)();
           this.masterGain = this.ctx.createGain();
           this.masterGain.gain.value = 0.3;
           this.masterGain.connect(this.ctx.destination);
           
           // Underwater drone
           this.droneBass = this.ctx.createOscillator();
           this.droneBass.type = 'sine';
           this.droneBass.frequency.value = 55;
           
           this.droneFilter = this.ctx.createBiquadFilter();
           this.droneFilter.type = 'lowpass';
           this.droneFilter.frequency.value = 200;
           this.droneFilter.Q.value = 2;
           
           this.droneBass.connect(this.droneFilter);
           this.droneFilter.connect(this.masterGain);
           this.droneBass.start();
       } catch(e) {
           console.log('Audio context unavailable');
       }
   }
   
   updateTide(tideLevel) {
       if (!this.ctx) return;
       const freq = 100 + tideLevel * 300;
       this.droneFilter.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.1);
   }
   
   playPlink() { this.playSynth(440, 0.05, 'sine', 0.1); }
   playStrike() { this.playSynth(220, 0.1, 'sawtooth', 0.2); }
   playBloom() { this.playSynth(880, 0.3, 'sine', 0.05); }
   playCrash() { this.playNoise(0.5, 0.3); }
   
   playSynth(freq, dur, type, vol) {
       if (!this.ctx) return;
       const osc = this.ctx.createOscillator();
       const env = this.ctx.createGain();
       osc.type = type;
       osc.frequency.value = freq;
       env.gain.value = 0;
       env.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.01);
       env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
       osc.connect(env);
       env.connect(this.masterGain);
       osc.start();
       osc.stop(this.ctx.currentTime + dur);
   }
   
   playNoise(dur, vol) {
       if (!this.ctx) return;
       const bufferSize = this.ctx.sampleRate * dur;
       const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
       const data = buffer.getChannelData(0);
       for (let i = 0; i < bufferSize; i++) {
           data[i] = Math.random() * 2 - 1;
       }
       const src = this.ctx.createBufferSource();
       const env = this.ctx.createGain();
       src.buffer = buffer;
       env.gain.value = vol;
       env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
       src.connect(env);
       env.connect(this.masterGain);
       src.start();
   }
}

// Current field simulation
class CurrentField {
   constructor(w, h) {
       this.w = w;
       this.h = h;
       this.time = 0;
       this.scale = 0.002;
   }
   
   update(dt) {
       this.time += dt * 0.2;
   }
   
   getFlow(pos) {
       const t = this.time;
       const s = this.scale;
       const x = pos.x * s;
       const y = pos.y * s;
       
       // Layered sinusoidal flow patterns
       const angle = Math.sin(x + t) * Math.cos(y * 0.7 + t * 0.8) +
                    Math.sin(x * 1.3 - t * 0.6) * Math.cos(y + t) * 0.5;
       
       return new Vec(Math.cos(angle) * 30, Math.sin(angle) * 20);
   }
}

// Tide system
class TideSystem {
   constructor() {
       this.time = 0;
       this.period = 180; // 3 minute cycle
       this.minLevel = 0.3;
       this.maxLevel = 1.0;
       this.surgeTimer = 0;
       this.surgeActive = false;
   }
   
   update(dt) {
       this.time += dt;
       
       // Rare surge events
       if (Math.random() < dt * 0.001 && !this.surgeActive) {
           this.surgeActive = true;
           this.surgeTimer = 3;
       }
       
       if (this.surgeActive) {
           this.surgeTimer -= dt;
           if (this.surgeTimer <= 0) this.surgeActive = false;
       }
   }
   
   getLevel() {
       const base = (Math.sin(this.time * Math.PI * 2 / this.period) + 1) * 0.5;
       const level = this.minLevel + base * (this.maxLevel - this.minLevel);
       return this.surgeActive ? Math.min(1, level + 0.3) : level;
   }
   
   getWaterline(canvasHeight) {
       return canvasHeight * (1 - this.getLevel());
   }
}

// Base entity class
class Entity {
   constructor(pos) {
       this.pos = pos;
       this.vel = new Vec();
       this.alive = true;
   }
   
   update(dt, current) {
       const flow = current.getFlow(this.pos);
       this.vel = this.vel.mul(0.98).add(flow.mul(dt * 0.001));
       this.pos = this.pos.add(this.vel.mul(dt));
   }
}

// Prey types with unique behaviors
class Prey extends Entity {
   constructor(pos, type = 'plankton') {
       super(pos);
       this.type = type;
       this.radius = { plankton: 3, shrimp: 6, fish: 10 }[type];
       this.atp = { plankton: 5, shrimp: 15, fish: 30 }[type];
       this.speed = { plankton: 10, shrimp: 30, fish: 50 }[type];
       this.phase = Math.random() * Math.PI * 2;
       this.wiggle = Math.random() * 0.5 + 0.5;
       this.targetAngle = Math.random() * Math.PI * 2;
       this.color = { 
           plankton: 'rgba(150,255,200,0.8)',
           shrimp: 'rgba(255,180,150,0.9)',
           fish: 'rgba(100,200,255,0.9)'
       }[type];
   }
   
   update(dt, current, polyps, bounds) {
       super.update(dt, current);
       this.phase += dt * this.wiggle * 2;
       
       // Type-specific AI
       if (this.type === 'fish') {
           // Fish avoid polyps
           let avoidance = new Vec();
           for (const p of polyps) {
               if (!p.alive) continue;
               const d = this.pos.dist(p.pos);
               if (d < 80) {
                   avoidance = avoidance.add(this.pos.sub(p.pos).norm().mul(100 / d));
               }
           }
           this.vel = this.vel.add(avoidance.mul(dt * 0.01));
           
           // Fish school behavior
           this.targetAngle += (Math.random() - 0.5) * dt;
           const targetVel = new Vec(Math.cos(this.targetAngle), Math.sin(this.targetAngle)).mul(this.speed);
           this.vel = this.vel.lerp(targetVel, dt * 0.5);
       } else if (this.type === 'shrimp') {
           // Shrimp dart movement
           if (Math.random() < dt * 0.5) {
               this.vel = this.vel.add(new Vec(
                   (Math.random() - 0.5) * this.speed,
                   (Math.random() - 0.5) * this.speed
               ));
           }
       } else {
           // Plankton drift
           const drift = new Vec(
               Math.sin(this.phase) * this.speed * 0.3,
               Math.cos(this.phase * 0.7) * this.speed * 0.2
           );
           this.vel = this.vel.add(drift.mul(dt * 0.01));
       }
       
       // Bounds
       if (this.pos.x < 20 || this.pos.x > bounds.x - 20) this.vel.x *= -1;
       if (this.pos.y < 20 || this.pos.y > bounds.y - 20) this.vel.y *= -1;
       this.pos.x = Math.max(20, Math.min(bounds.x - 20, this.pos.x));
       this.pos.y = Math.max(20, Math.min(bounds.y - 20, this.pos.y));
   }
   
   render(ctx, camOffset) {
       const p = this.pos.add(camOffset);
       ctx.save();
       
       if (this.type === 'fish') {
           // Fish shape
           ctx.translate(p.x, p.y);
           ctx.rotate(Math.atan2(this.vel.y, this.vel.x));
           ctx.fillStyle = this.color;
           ctx.beginPath();
           ctx.ellipse(0, 0, this.radius * 1.5, this.radius * 0.7, 0, 0, Math.PI * 2);
           ctx.fill();
           // Tail
           ctx.beginPath();
           ctx.moveTo(-this.radius, 0);
           ctx.lineTo(-this.radius * 2, -this.radius * 0.5);
           ctx.lineTo(-this.radius * 2, this.radius * 0.5);
           ctx.closePath();
           ctx.fill();
       } else if (this.type === 'shrimp') {
           // Shrimp shape
           ctx.translate(p.x, p.y);
           ctx.rotate(Math.atan2(this.vel.y, this.vel.x));
           ctx.fillStyle = this.color;
           ctx.beginPath();
           ctx.ellipse(0, 0, this.radius, this.radius * 0.5, 0, 0, Math.PI * 2);
           ctx.fill();
           // Antennae
           ctx.strokeStyle = this.color;
           ctx.lineWidth = 1;
           ctx.beginPath();
           ctx.moveTo(this.radius, -2);
           ctx.lineTo(this.radius + 5, -4);
           ctx.moveTo(this.radius, 2);
           ctx.lineTo(this.radius + 5, 4);
           ctx.stroke();
       } else {
           // Plankton glow
           const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, this.radius * 2);
           glow.addColorStop(0, this.color);
           glow.addColorStop(1, 'rgba(150,255,200,0)');
           ctx.fillStyle = glow;
           ctx.fillRect(p.x - this.radius * 2, p.y - this.radius * 2, this.radius * 4, this.radius * 4);
       }
       
       ctx.restore();
   }
}

// Predator base
class Predator extends Entity {
   constructor(pos, type = 'whelk') {
       super(pos);
       this.type = type;
       this.radius = 15;
       this.speed = 20;
       this.huntTimer = 0;
       this.target = null;
   }
   
   update(dt, current, polyps, bounds) {
       super.update(dt, current);
       this.huntTimer -= dt;
       
       // Hunt polyps
       if (this.huntTimer <= 0 && polyps.length > 0) {
           this.target = polyps[Math.floor(Math.random() * polyps.length)];
           this.huntTimer = 10 + Math.random() * 10;
       }
       
       if (this.target && this.target.alive) {
           const toTarget = this.target.pos.sub(this.pos);
           const dist = toTarget.len();
           if (dist > 5) {
               this.vel = this.vel.add(toTarget.norm().mul(this.speed * dt * 0.01));
           }
           
           // Attack
           if (dist < this.radius + 10) {
               this.target.takeDamage(dt * 5);
           }
       }
       
       // Bounds
       if (this.pos.x < 20 || this.pos.x > bounds.x - 20) this.vel.x *= -0.5;
       if (this.pos.y < 20 || this.pos.y > bounds.y - 20) this.vel.y *= -0.5;
       this.pos.x = Math.max(20, Math.min(bounds.x - 20, this.pos.x));
       this.pos.y = Math.max(20, Math.min(bounds.y - 20, this.pos.y));
   }
   
   render(ctx, camOffset) {
       const p = this.pos.add(camOffset);
       
       // Whelk shell spiral
       ctx.save();
       ctx.translate(p.x, p.y);
       ctx.rotate(Math.atan2(this.vel.y, this.vel.x) + Math.PI / 2);
       
       const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
       gradient.addColorStop(0, 'rgba(150,100,80,0.9)');
       gradient.addColorStop(0.7, 'rgba(100,70,50,0.9)');
       gradient.addColorStop(1, 'rgba(80,50,40,0.9)');
       ctx.fillStyle = gradient;
       
       // Spiral shell
       ctx.beginPath();
       for (let i = 0; i < 50; i++) {
           const angle = i * 0.3;
           const r = this.radius * (1 - i / 50);
           const x = Math.cos(angle) * r;
           const y = Math.sin(angle) * r * 0.7;
           if (i === 0) ctx.moveTo(x, y);
           else ctx.lineTo(x, y);
       }
       ctx.fill();
       
       ctx.restore();
   }
}

// Polyp anemone class
class Polyp {
   constructor(pos, parent = null) {
       this.pos = pos;
       this.parent = parent;
       this.alive = true;
       this.health = 100;
       this.atp = 10;
       this.cooldown = 0;
       this.tentacles = [];
       this.baseRadius = 15;
       this.glowIntensity = 0;
       this.wobble = Math.random() * Math.PI * 2;
       this.mutation = parent ? this.inheritMutation() : null;
       
       // Generate tentacles
       const count = 8 + Math.floor(Math.random() * 4);
       for (let i = 0; i < count; i++) {
           this.tentacles.push({
               angle: (i / count) * Math.PI * 2 + (Math.random() - 0.5) * 0.3,
               length: 20 + Math.random() * 15,
               phase: Math.random() * Math.PI * 2,
               thickness: 2 + Math.random()
           });
       }
   }
   
   inheritMutation() {
       if (Math.random() < 0.1) {
           return ['longReach', 'toxin', 'drought'][Math.floor(Math.random() * 3)];
       }
       return this.parent.mutation;
   }
   
   update(dt, tide, waterline) {
       this.cooldown = Math.max(0, this.cooldown - dt);
       this.wobble += dt * 0.5;
       this.glowIntensity *= 0.95;
       
       // Tide damage
       if (this.pos.y < waterline) {
           const damage = (waterline - this.pos.y) * dt * 0.5;
           this.health -= this.mutation === 'drought' ? damage * 0.3 : damage;
       }
       
       // Death check
       if (this.health <= 0) {
           this.alive = false;
       }
       
       // Passive ATP generation
       if (this.pos.y > waterline && this.atp < 100) {
           this.atp += dt * 0.5;
       }
   }
   
   sting(prey, audio) {
       if (this.cooldown > 0) return false;
       
       const reach = this.mutation === 'longReach' ? 60 : 40;
       const dist = this.pos.dist(prey.pos);
       
       if (dist < reach) {
           this.atp += prey.atp;
           this.cooldown = 2;
           this.glowIntensity = 1;
           audio.playStrike();
           
           // Wobble tentacles
           this.tentacles.forEach(t => t.phase += Math.random() * 2);
           
           return true;
       }
       return false;
   }
   
   canClone() {
       return this.atp >= 50 && this.cooldown <= 0;
   }
   
   clone(targetPos, audio) {
       if (!this.canClone()) return null;
       
       this.atp -= 50;
       this.cooldown = 5;
       this.glowIntensity = 2;
       audio.playBloom();
       
       return new Polyp(targetPos, this);
   }
   
   takeDamage(amount) {
       this.health -= amount;
       this.glowIntensity = Math.max(this.glowIntensity, 0.5);
   }
   
   render(ctx, camOffset, waterline, time) {
       const p = this.pos.add(camOffset);
       const submerged = this.pos.y > waterline;
       
       ctx.save();
       
       // Base
       const baseGradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, this.baseRadius);
       const healthFactor = this.health / 100;
       const r = 50 + (1 - healthFactor) * 100;
       const g = 100 + healthFactor * 100;
       const b = 150 + healthFactor * 105;
       
       baseGradient.addColorStop(0, `rgba(${r},${g},${b},0.9)`);
       baseGradient.addColorStop(1, `rgba(${r*0.5},${g*0.5},${b*0.5},0.7)`);
       
       ctx.fillStyle = baseGradient;
       ctx.beginPath();
       ctx.arc(p.x, p.y, this.baseRadius, 0, Math.PI * 2);
       ctx.fill();
       
       // Tentacles
       ctx.lineCap = 'round';
       this.tentacles.forEach((t, i) => {
           const wave = Math.sin(time * 2 + t.phase + this.wobble) * 0.3;
           const angle = t.angle + wave;
           const length = t.length * (submerged ? 1 : 0.6);
           
           // Tentacle gradient
           const tGradient = ctx.createLinearGradient(
               p.x, p.y,
               p.x + Math.cos(angle) * length,
               p.y + Math.sin(angle) * length
           );
           tGradient.addColorStop(0, `rgba(${r},${g},${b},0.8)`);
           tGradient.addColorStop(1, `rgba(${r*0.7},${g*0.7},${b*1.2},0.3)`);
           
           ctx.strokeStyle = tGradient;
           ctx.lineWidth = t.thickness * (submerged ? 1 : 0.7);
           
           ctx.beginPath();
           ctx.moveTo(p.x, p.y);
           
           // Bezier curve tentacle
           const cp1x = p.x + Math.cos(angle - 0.2) * length * 0.3;
           const cp1y = p.y + Math.sin(angle - 0.2) * length * 0.3;
           const cp2x = p.x + Math.cos(angle + 0.1) * length * 0.7;
           const cp2y = p.y + Math.sin(angle + 0.1) * length * 0.7;
           const endx = p.x + Math.cos(angle) * length;
           const endy = p.y + Math.sin(angle) * length;
           
           ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endx, endy);
           ctx.stroke();
       });
       
       // Glow effect
       if (this.glowIntensity > 0.1) {
           const glowGradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 40);
           glowGradient.addColorStop(0, `rgba(100,200,255,${this.glowIntensity * 0.3})`);
           glowGradient.addColorStop(1, 'rgba(100,200,255,0)');
           ctx.fillStyle = glowGradient;
           ctx.fillRect(p.x - 40, p.y - 40, 80, 80);
       }
       
       // ATP indicator (subtle glow)
       if (this.atp >= 50) {
           const ready = ctx.createRadialGradient(p.x, p.y, this.baseRadius * 0.8, p.x, p.y, this.baseRadius);
           ready.addColorStop(0, 'rgba(150,255,150,0)');
           ready.addColorStop(1, 'rgba(150,255,150,0.4)');
           ctx.fillStyle = ready;
           ctx.beginPath();
           ctx.arc(p.x, p.y, this.baseRadius, 0, Math.PI * 2);
           ctx.fill();
       }
       
       ctx.restore();
   }
}

// Rock formations
class Rock {
   constructor(x, y, seed) {
       this.x = x;
       this.y = y;
       this.seed = seed;
       this.points = [];
       
       // Generate rock shape
       const angles = 8 + Math.floor(seed * 4);
       for (let i = 0; i < angles; i++) {
           const angle = (i / angles) * Math.PI * 2;
           const radius = 30 + seed * 20 + Math.sin(angle * 3 + seed * 10) * 10;
           this.points.push({
               x: Math.cos(angle) * radius,
               y: Math.sin(angle) * radius * 0.7
           });
       }
   }
   
   render(ctx, camOffset, depth = 1) {
       const p = new Vec(this.x, this.y).add(camOffset);
       
       ctx.save();
       ctx.translate(p.x, p.y);
       
       // Shadow
       ctx.fillStyle = `rgba(0,0,20,${0.3 * depth})`;
       ctx.beginPath();
       ctx.moveTo(this.points[0].x + 5, this.points[0].y + 5);
       this.points.forEach(pt => ctx.lineTo(pt.x + 5, pt.y + 5));
       ctx.closePath();
       ctx.fill();
       
       // Rock gradient
       const gradient = ctx.createRadialGradient(0, -10, 0, 0, 0, 40);
       const lightness = 40 + depth * 20;
       gradient.addColorStop(0, `rgba(${lightness},${lightness},${lightness + 10},0.9)`);
       gradient.addColorStop(1, `rgba(${lightness * 0.7},${lightness * 0.7},${lightness * 0.7},0.9)`);
       
       ctx.fillStyle = gradient;
       ctx.beginPath();
       ctx.moveTo(this.points[0].x, this.points[0].y);
       this.points.forEach(pt => ctx.lineTo(pt.x, pt.y));
       ctx.closePath();
       ctx.fill();
       
       ctx.restore();
   }
}

// Main renderer
class Renderer {
   constructor(canvas) {
       this.canvas = canvas;
       this.ctx = canvas.getContext('2d');
       this.camOffset = new Vec();
       this.camDrift = 0;
       this.particles = [];
       
       this.resize();
       window.addEventListener('resize', () => this.resize());
   }
   
   resize() {
       this.canvas.width = window.innerWidth;
       this.canvas.height = window.innerHeight;
   }
   
   update(dt) {
       // Camera drift
       this.camDrift += dt * 0.3;
       this.camOffset = new Vec(
           Math.sin(this.camDrift) * 1,
           Math.cos(this.camDrift * 0.7) * 1
       );
       
       // Update particles
       this.particles = this.particles.filter(p => {
           p.life -= dt;
           p.y -= dt * 10;
           p.x += Math.sin(p.phase) * dt * 5;
           return p.life > 0;
       });
   }
   
   addBubbles(pos, count = 5) {
       for (let i = 0; i < count; i++) {
           this.particles.push({
               x: pos.x + (Math.random() - 0.5) * 20,
               y: pos.y,
               life: 2 + Math.random(),
               size: 2 + Math.random() * 3,
               phase: Math.random() * Math.PI * 2
           });
       }
   }
   
   render(game) {
       const ctx = this.ctx;
       const w = this.canvas.width;
       const h = this.canvas.height;
       
       // Deep ocean gradient
       const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
       bgGradient.addColorStop(0, '#001122');
       bgGradient.addColorStop(0.5, '#002244');
       bgGradient.addColorStop(1, '#003366');
       ctx.fillStyle = bgGradient;
       ctx.fillRect(0, 0, w, h);
       
       // Caustic light rays
       ctx.save();
       ctx.globalCompositeOperation = 'screen';
       ctx.globalAlpha = 0.1;
       for (let i = 0; i < 5; i++) {
           const x = Math.sin(game.time * 0.2 + i * 1.7) * 100 + w * (i + 1) / 6;
           const gradient = ctx.createLinearGradient(x - 50, 0, x + 50, h);
           gradient.addColorStop(0, 'rgba(100,200,255,0)');
           gradient.addColorStop(0.5, 'rgba(100,200,255,0.5)');
           gradient.addColorStop(1, 'rgba(100,200,255,0)');
           ctx.fillStyle = gradient;
           ctx.fillRect(x - 50, 0, 100, h);
       }
       ctx.restore();
       
       // Background rocks (parallax)
       game.rocks.forEach(rock => {
           if (rock.y > h * 0.5) {
               rock.render(ctx, this.camOffset.mul(0.5), 0.5);
           }
       });
       
       // Water surface
       const waterline = game.tide.getWaterline(h);
       ctx.save();
       ctx.globalAlpha = 0.3;

    // Water gradient
       const waterGradient = ctx.createLinearGradient(0, waterline, 0, h);
       waterGradient.addColorStop(0, 'rgba(100,200,255,0.2)');
       waterGradient.addColorStop(0.5, 'rgba(50,150,220,0.4)');
       waterGradient.addColorStop(1, 'rgba(20,80,150,0.6)');
       ctx.fillStyle = waterGradient;
       ctx.fillRect(0, waterline, w, h - waterline);
       
       // Surface waves
       ctx.strokeStyle = 'rgba(200,255,255,0.3)';
       ctx.lineWidth = 2;
       ctx.beginPath();
       for (let x = 0; x <= w; x += 20) {
           const y = waterline + Math.sin(x * 0.02 + game.time) * 5;
           if (x === 0) ctx.moveTo(x, y);
           else ctx.lineTo(x, y);
       }
       ctx.stroke();
       ctx.restore();
       
       // Render entities
       game.prey.forEach(p => p.render(ctx, this.camOffset));
       game.predators.forEach(p => p.render(ctx, this.camOffset));
       
       // Foreground rocks
       game.rocks.forEach(rock => {
           if (rock.y <= h * 0.5) {
               rock.render(ctx, this.camOffset, 1);
           }
       });
       
       // Polyps
       game.polyps.forEach(p => p.render(ctx, this.camOffset, waterline, game.time));
       
       // Particles
       ctx.save();
       ctx.globalAlpha = 0.6;
       ctx.fillStyle = 'rgba(200,255,255,0.8)';
       this.particles.forEach(p => {
           const pos = new Vec(p.x, p.y).add(this.camOffset);
           ctx.beginPath();
           ctx.arc(pos.x, pos.y, p.size * (p.life / 2), 0, Math.PI * 2);
           ctx.fill();
       });
       ctx.restore();
       
       // Grain overlay
       ctx.save();
       ctx.globalAlpha = 0.04;
       const imageData = ctx.createImageData(w, h);
       const data = imageData.data;
       for (let i = 0; i < data.length; i += 4) {
           const noise = Math.random() * 255;
           data[i] = noise;
           data[i + 1] = noise;
           data[i + 2] = noise;
           data[i + 3] = 255;
       }
       ctx.putImageData(imageData, 0, 0);
       ctx.restore();
       
       // Vignette
       const vignette = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h) * 0.7);
       vignette.addColorStop(0, 'rgba(0,0,0,0)');
       vignette.addColorStop(1, 'rgba(0,0,0,0.4)');
       ctx.fillStyle = vignette;
       ctx.fillRect(0, 0, w, h);
   }
}

// Main game class
class Game {
   constructor() {
       this.canvas = document.getElementById('game');
       this.renderer = new Renderer(this.canvas);
       this.audio = new AudioBus();
       this.currentField = new CurrentField(window.innerWidth, window.innerHeight);
       this.tide = new TideSystem();
       
       this.time = 0;
       this.polyps = [];
       this.prey = [];
       this.predators = [];
       this.rocks = [];
       this.bounds = new Vec(window.innerWidth, window.innerHeight);
       
       this.lastTime = performance.now();
       this.init();
       this.setupControls();
       this.loop();
   }
   
   init() {
       // Generate rocks
       for (let i = 0; i < 15; i++) {
           this.rocks.push(new Rock(
               Math.random() * this.bounds.x,
               Math.random() * this.bounds.y,
               Math.random()
           ));
       }
       
       // Starting polyp
       this.polyps.push(new Polyp(new Vec(this.bounds.x / 2, this.bounds.y * 0.7)));
       
       // Initial prey
       for (let i = 0; i < 20; i++) {
           const types = ['plankton', 'plankton', 'plankton', 'shrimp', 'fish'];
           const type = types[Math.floor(Math.random() * types.length)];
           this.prey.push(new Prey(
               new Vec(Math.random() * this.bounds.x, Math.random() * this.bounds.y),
               type
           ));
       }
       
       // Initial predator
       this.predators.push(new Predator(
           new Vec(Math.random() * this.bounds.x, Math.random() * this.bounds.y)
       ));
   }
   
   setupControls() {
       // Mouse controls
       this.canvas.addEventListener('click', (e) => this.handleClick(e.clientX, e.clientY));
       
       // Touch controls
       let touchTimer = null;
       let touchStart = null;
       
       this.canvas.addEventListener('touchstart', (e) => {
           e.preventDefault();
           const touch = e.touches[0];
           touchStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
           touchTimer = setTimeout(() => {
               this.handleLongPress(touch.clientX, touch.clientY);
               touchTimer = null;
           }, 500);
       });
       
       this.canvas.addEventListener('touchend', (e) => {
           e.preventDefault();
           if (touchTimer) {
               clearTimeout(touchTimer);
               if (Date.now() - touchStart.time < 500) {
                   this.handleClick(touchStart.x, touchStart.y);
               }
           }
       });
       
       this.canvas.addEventListener('touchmove', (e) => {
           e.preventDefault();
           if (touchTimer) {
               clearTimeout(touchTimer);
               touchTimer = null;
           }
       });
       
       // Keyboard
       window.addEventListener('keydown', (e) => {
           if (e.key === 'r' || e.key === 'R') {
               this.reset();
           }
       });
   }
   
   handleClick(x, y) {
       const worldPos = new Vec(x, y).sub(this.renderer.camOffset);
       
       // Check if clicking on prey near a polyp
       let stung = false;
       for (const polyp of this.polyps) {
           if (!polyp.alive || polyp.cooldown > 0) continue;
           
           for (let i = this.prey.length - 1; i >= 0; i--) {
               const p = this.prey[i];
               if (p.pos.dist(worldPos) < p.radius + 10) {
                   if (polyp.sting(p, this.audio)) {
                       this.prey.splice(i, 1);
                       this.renderer.addBubbles(p.pos, 3);
                       stung = true;
                       break;
                   }
               }
           }
           if (stung) break;
       }
       
       // If not stinging, try to clone
       if (!stung) {
           this.tryClone(worldPos);
       }
   }
   
   handleLongPress(x, y) {
       const worldPos = new Vec(x, y).sub(this.renderer.camOffset);
       this.tryClone(worldPos);
   }
   
   tryClone(targetPos) {
       // Find nearest polyp that can clone
       let nearest = null;
       let nearestDist = Infinity;
       
       for (const polyp of this.polyps) {
           if (!polyp.alive || !polyp.canClone()) continue;
           const dist = polyp.pos.dist(targetPos);
           if (dist < nearestDist) {
               nearest = polyp;
               nearestDist = dist;
           }
       }
       
       if (nearest && nearestDist < 150) {
           // Check if position is valid (on rock)
           let onRock = false;
           for (const rock of this.rocks) {
               if (new Vec(rock.x, rock.y).dist(targetPos) < 50) {
                   onRock = true;
                   break;
               }
           }
           
           if (onRock) {
               const newPolyp = nearest.clone(targetPos, this.audio);
               if (newPolyp) {
                   this.polyps.push(newPolyp);
                   this.renderer.addBubbles(targetPos, 10);
               }
           }
       }
   }
   
   reset() {
       this.polyps = [];
       this.prey = [];
       this.predators = [];
       this.init();
   }
   
   update(dt) {
       this.time += dt;
       
       // Update systems
       this.currentField.update(dt);
       this.tide.update(dt);
       this.renderer.update(dt);
       this.audio.updateTide(this.tide.getLevel());
       
       const waterline = this.tide.getWaterline(this.bounds.y);
       
       // Update entities
       this.polyps = this.polyps.filter(p => {
           if (p.alive) p.update(dt, this.tide, waterline);
           return p.alive;
       });
       
       this.prey.forEach(p => p.update(dt, this.currentField, this.polyps, this.bounds));
       this.predators.forEach(p => p.update(dt, this.currentField, this.polyps, this.bounds));
       
       // Spawn new prey
       if (Math.random() < dt * 0.5 && this.prey.length < 50) {
           const types = ['plankton', 'plankton', 'plankton', 'shrimp', 'fish'];
           const type = types[Math.floor(Math.random() * types.length)];
           const edge = Math.random() < 0.5;
           const pos = edge ? 
               new Vec(Math.random() < 0.5 ? 0 : this.bounds.x, Math.random() * this.bounds.y) :
               new Vec(Math.random() * this.bounds.x, Math.random() < 0.5 ? 0 : this.bounds.y);
           
           this.prey.push(new Prey(pos, type));
           this.audio.playPlink();
       }
       
       // Rare surge
       if (this.tide.surgeActive && Math.random() < dt) {
           this.audio.playCrash();
           this.renderer.addBubbles(new Vec(Math.random() * this.bounds.x, waterline), 20);
       }
       
       // TODO: Seabird predator
       // TODO: Sea star implementation
   }
   
   loop() {
       const now = performance.now();
       const dt = Math.min((now - this.lastTime) / 1000, 0.1);
       this.lastTime = now;
       
       this.update(dt);
       this.renderer.render(this);
       
       requestAnimationFrame(() => this.loop());
   }
}

// Start game when loaded
window.addEventListener('load', () => {
   new Game();
});
</script>
</body>
</html>
