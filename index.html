<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>POLYP – Tide-Pool Colony Sim</title>
  <style>
    /* --- BASIC RESET & CANVAS LAYOUT --- */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #030b14; /* deep-sea indigo */
      touch-action: none;
      font-family: system-ui, sans-serif;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    /* =============================================================
       POLYP  — meditative tide-pool life-sim in a single HTML file
       ============================================================= */

    /* ---------- UTILS ---------- */
    class Vec {
      constructor(x = 0, y = 0) {
        this.x = x; this.y = y;
      }
      add(v) { this.x += v.x; this.y += v.y; return this; }
      sub(v) { this.x -= v.x; this.y -= v.y; return this; }
      mul(s) { this.x *= s; this.y *= s; return this; }
      clone() { return new Vec(this.x, this.y); }
      len() { return Math.hypot(this.x, this.y); }
      norm() { const l = this.len() || 1; return this.mul(1 / l); }
    }
    const rand = (a = 1, b = 0) => Math.random() * (b - a) + a;

    /* ---------- CANVAS ---------- */
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    let W = 0, H = 0, DPR = window.devicePixelRatio || 1;
    const resize = () => {
      W = window.innerWidth; H = window.innerHeight;
      canvas.width = W * DPR; canvas.height = H * DPR;
      ctx.scale(DPR, DPR);
    };
    window.addEventListener("resize", resize);
    resize();

    /* ---------- GLOBAL SIM STATE ---------- */
    const ROCK_LINE = 0.75; // portion of screen height that is rock substrate
    let time = 0;
    const polyps = []; const preys = []; const predators = [];

    /* ---------- CURRENT & TIDE ---------- */
    function currentVector(t) {
      // gentle oscillating flow with periodic  wave surges
      const baseDir = Math.sin(t * 0.00006) * Math.PI; // -π .. π over ~2 min
      const speed = 30 + 20 * Math.sin(t * 0.0004);
      return new Vec(Math.cos(baseDir), Math.sin(baseDir)).mul(speed * 0.016);
    }
    function tideLevel(t) {
      // 0 (low) .. 1 (high)
      return 0.6 + 0.4 * Math.sin(t * 0.00005); // full cycle ~3 min
    }

    /* ---------- ENTITY CLASSES ---------- */
    class Polyp {
      constructor(x, y) {
        this.pos = new Vec(x, y);
        this.energy = 0;
        this.radius = 20; // visual size
        this.stingRange = 60;
        this.cooldown = 0;
        this.highlight = 0; // for hover feedback
        this.hp = 100;
      }
      update(dt, idx) {
        // dry-out if above tide
        const waterY = H * tideLevel(time);
        if (this.pos.y < waterY) {
          this.hp -= dt * 3; // drying
        } else {
          this.hp = Math.min(this.hp + dt * 10, 100);
        }
        if (this.hp <= 0) polyps.splice(idx, 1);
        this.energy = Math.min(this.energy + dt * 2, 100);
        if (this.cooldown > 0) this.cooldown -= dt;
        if (this.highlight > 0) this.highlight -= dt * 3;
      }
      draw() {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        // pulsing core glow indicates energy
        const glow = this.energy / 100;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(100,200,255,${0.1 + glow * 0.3})`;
        ctx.fill();
        // body
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.65, 0, Math.PI * 2);
        ctx.fillStyle = `hsl(${180 + glow * 120},60%,${40 + glow * 20}%)`;
        ctx.fill();
        // highlight ring on hover
        if (this.highlight > 0) {
          ctx.lineWidth = 4;
          ctx.strokeStyle = `rgba(255,255,255,${this.highlight})`;
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 4, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }
      sting() {
        if (this.cooldown > 0) return;
        // visual sweep & capture prey in range
        const sweepSteps = 18, stepAngle = (2 * Math.PI) / sweepSteps;
        for (let p = preys.length - 1; p >= 0; p--) {
          const prey = preys[p];
          if (prey.pos.clone().sub(this.pos).len() < this.stingRange) {
            this.energy = Math.min(this.energy + prey.atp, 100);
            preys.splice(p, 1);
          }
        }
        this.cooldown = 1; // seconds
      }
      canCloneAt(v) {
        // must be on rock and empty space
        const waterY = H * tideLevel(time);
        if (v.y > H * ROCK_LINE) return false; // sand zone below rocks
        if (v.y < waterY - 10) return false; // must be submerged at placement time
        for (const p of polyps) {
          if (p.pos.clone().sub(v).len() < this.radius * 2) return false;
        }
        return true;
      }
      tryClone(target) {
        if (this.energy < 50) return false;
        if (this.canCloneAt(target)) {
          polyps.push(new Polyp(target.x, target.y));
          this.energy -= 50;
          return true;
        }
        return false;
      }
    }

    class Prey {
      constructor(x, y, type = "plankton") {
        this.pos = new Vec(x, y);
        this.type = type;
        this.dir = new Vec(rand(-1, 1), rand(-1, 1)).norm();
        this.speed = { plankton: 15, shrimp: 30, fish: 60 }[type];
        this.atp = { plankton: 5, shrimp: 12, fish: 25 }[type];
        this.evade = type === "fish";
      }
      update(dt) {
        const flow = currentVector(time);
        if (this.evade) this.dir.add(new Vec(rand(-0.2, 0.2), rand(-0.2, 0.2))).norm();
        const vel = this.dir.clone().mul(this.speed).add(flow);
        this.pos.add(vel.mul(dt));
        // wrap around screen
        if (this.pos.x < -20) this.pos.x = W + 20;
        if (this.pos.x > W + 20) this.pos.x = -20;
        if (this.pos.y < 0) this.pos.y = H;
        if (this.pos.y > H) this.pos.y = 0;
      }
      draw() {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        let color = { plankton: "#9ff", shrimp: "#ff9", fish: "#6f9" }[this.type];
        ctx.fillStyle = color;
        switch (this.type) {
          case "plankton":
            ctx.fillRect(-2, -2, 4, 4);
            break;
          case "shrimp":
            ctx.beginPath();
            ctx.moveTo(-3, 0); ctx.lineTo(3, 0); ctx.lineTo(0, -4);
            ctx.closePath(); ctx.fill();
            break;
          case "fish":
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill();
            ctx.fillRect(3, -1, 4, 2); // tail
            break;
        }
        ctx.restore();
      }
    }

    // simple whelk predator that creeps along rock bottom
    class Whelk {
      constructor(x) {
        this.pos = new Vec(x, H * ROCK_LINE - 5);
        this.speed = 10;
        this.dir = Math.random() < 0.5 ? -1 : 1;
      }
      update(dt) {
        this.pos.x += this.dir * this.speed * dt;
        if (this.pos.x < 0 || this.pos.x > W) this.dir *= -1;
        // check for polyp overlap
        for (let i = polyps.length - 1; i >= 0; i--) {
          if (polyps[i].pos.clone().sub(this.pos).len() < 15) {
            polyps.splice(i, 1);
          }
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.fillStyle = "#b99";
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    /* ---------- INIT ---------- */
    function seed() {
      polyps.length = 0; preys.length = 0; predators.length = 0;
      polyps.push(new Polyp(W * 0.5, H * 0.5));
      // sprinkle prey
      for (let i = 0; i < 60; i++) preys.push(new Prey(rand(0, W), rand(0, H * 0.9)));
      predators.push(new Whelk(rand(0, W)));
    }
    seed();

    /* ---------- INPUT ---------- */
    let pointer = null;
    canvas.addEventListener("pointermove", e => {
      pointer = { x: e.clientX, y: e.clientY };
    });
    canvas.addEventListener("pointerleave", () => (pointer = null));

    canvas.addEventListener("pointerdown", e => {
      const pt = new Vec(e.clientX, e.clientY);
      let acted = false;
      // attempt sting first
      for (const p of polyps) {
        if (p.pos.clone().sub(pt).len() < p.radius * 1.2) {
          p.sting();
          acted = true;
          break;
        }
      }
      if (!acted) {
        // clone from nearest polyp with energy
        let nearest = null, dist = 1e9;
        for (const p of polyps) {
          const d = p.pos.clone().sub(pt).len();
          if (d < dist) { dist = d; nearest = p; }
        }
        if (nearest) nearest.tryClone(pt);
      }
    });

    /* ---------- MAIN LOOP ---------- */
    let last = 0;
    function loop(ts) {
      const dt = Math.min((ts - last) / 1000, 0.1);
      last = ts; time = ts;

      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function update(dt) {
      polyps.forEach((p, i) => p.update(dt, i));
      preys.forEach(p => p.update(dt));
      predators.forEach(p => p.update(dt));
      // occasional respawn of prey
      if (Math.random() < 0.02) {
        const types = ["plankton", "shrimp", "fish"];
        preys.push(new Prey(rand(0, W), -10, types[Math.floor(rand(0, 3))]));
      }
    }

    /* ---------- RENDERING ---------- */
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // water background gradient that shifts with tide
      const grd = ctx.createLinearGradient(0, 0, 0, H);
      grd.addColorStop(0, "#012");
      grd.addColorStop(tideLevel(time) * ROCK_LINE, "#046");
      grd.addColorStop(tideLevel(time) * ROCK_LINE + 0.05, "#033");
      grd.addColorStop(1, "#130c08");
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);

      // rock substrate visual
      ctx.fillStyle = "#1b140e";
      ctx.fillRect(0, H * ROCK_LINE, W, H * (1 - ROCK_LINE));

      preys.forEach(p => p.draw());
      predators.forEach(p => p.draw());
      polyps.forEach(p => p.draw());

      // pointer hover feedback
      if (pointer) {
        for (const p of polyps) {
          if (p.pos.clone().sub(pointer).len() < p.radius) p.highlight = 1;
        }
      }
    }

    /* ---------- DEV HELPERS ---------- */
    window.addEventListener("keydown", e => {
      if (e.key === "r") seed(); // quick reset
    });
  </script>
</body>
</html>
