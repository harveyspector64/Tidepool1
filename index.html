<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coral Reef Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #001f3f; /* Deep sea blue */
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        #simulationCanvas {
            display: block;
            background-color: #003366; /* Slightly lighter sea blue for canvas */
            border-radius: 0.5rem; /* Rounded corners for the canvas */
            box-shadow: 0 0 20px rgba(0,191,255,0.5); /* DeepSkyBlue glow */
        }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .controls button, .controls input, .controls label {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background-color: #0077cc; /* Ocean blue button */
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        .controls button:hover {
            background-color: #005fa3;
        }
        .controls input[type="range"] {
            padding: 0;
        }
        .controls label {
            background-color: transparent;
        }
        .info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0,0,0,0.6);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 250px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="info-panel" id="infoPanel">
        <h2 class="text-lg font-semibold mb-2">Coral Reef Observer</h2>
        <p>Welcome to your personal coral reef! Watch as life unfolds in this dynamic ecosystem.</p>
        <p class="mt-2">Tips: Adjust fish count for performance. Try clicking to create a gentle ripple!</p>
        <p class="mt-1">Fish Count: <span id="fishCountDisplay">0</span></p>
    </div>

    <canvas id="simulationCanvas"></canvas>

    <div class="controls">
        <label for="fishSlider">Fish:</label>
        <input type="range" id="fishSlider" min="10" max="200" value="50" step="10">
        <button id="resetSimButton">Reset Simulation</button>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // --- Global Settings ---
        let fishCount = 50;
        const MAX_FISH = 200;
        const MIN_FISH = 10;

        // --- Entity Arrays ---
        let fishArray = [];
        let coralArray = [];
        let plantArray = [];
        let bubbleArray = [];
        let particleArray = []; // For plankton/detritus
        let lightRayArray = [];
        let rippleEffects = [];

        // --- Mouse Interaction ---
        let mouse = { x: undefined, y: undefined, clicked: false, clickX: 0, clickY: 0 };
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = event.clientX - rect.left;
            mouse.y = event.clientY - rect.top;
        });
        canvas.addEventListener('mouseleave', () => {
            mouse.x = undefined;
            mouse.y = undefined;
        });
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            mouse.clicked = true; // Flag that a click happened
            mouse.clickX = event.clientX - rect.left;
            mouse.clickY = event.clientY - rect.top;
            createRipple(mouse.clickX, mouse.clickY);
        });


        // --- Helper Functions ---
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(random(min, max + 1));
        }

        function getRandomColor(palette) {
            return palette[Math.floor(Math.random() * palette.length)];
        }
        
        // --- Color Palettes ---
        const fishPalette = ['#FF6B6B', '#FFD166', '#06D6A0', '#118AB2', '#EF476F', '#F78C6B', '#7F2CCB', '#FF9F1C'];
        const coralPalette = {
            brain: ['#D9A0A0', '#C78D8D', '#B57A7A'], // Rosy browns
            staghorn: ['#AEE8CC', '#98D7B8', '#82C6A4'], // Seafoam greens
            fan: ['#FCA3B7', '#FB8DA0', '#F97789'], // Soft pinks/reds
            pillar: ['#F0E68C', '#E0D878', '#D0CA64'], // Sandy yellows
            flower: ['#C3AED6', '#B09AC9', '#9E86BC'] // Lavender purples - will be base for PlayerPolyp
        };
        const plantPalette = ['#5FAD56', '#4E9A44', '#3D8732', '#70C1B3']; // Greens and teals

        // --- Entity Classes/Factories ---

        // Ripple Effect
        class RippleEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = random(40, 70);
                this.speed = random(0.5, 1);
                this.opacity = 1;
                this.lineWidth = random(2,4);
            }

            update() {
                this.radius += this.speed;
                this.opacity -= 0.02;
            }

            draw() {
                if (this.opacity <= 0) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(200, 220, 255, ${this.opacity})`;
                ctx.lineWidth = this.lineWidth;
                ctx.stroke();
            }
        }

        function createRipple(x, y) {
            if (rippleEffects.length < 10) { // Limit concurrent ripples
                rippleEffects.push(new RippleEffect(x,y));
            }
        }


        // Light Rays
        class LightRay {
            constructor() {
                this.x = random(0, canvas.width);
                this.y = 0;
                this.length = random(canvas.height * 0.6, canvas.height * 1.2);
                this.width = random(1, 3); // Slightly thinner on average
                this.opacity = random(0.03, 0.15); // Slightly more subtle
                this.baseAngle = random(-0.05, 0.05); // Initial slight angle
                this.angleSway = random(0.01, 0.03); // How much the angle sways
                this.angleSwaySpeed = random(0.0001, 0.0005);
                this.driftSpeed = random(-0.05, 0.05); // Slow horizontal drift
                this.time = random(0, Math.PI * 2); // For shimmering effect
            }

            update() {
                this.time += 0.01; // Consistent shimmer speed
                this.x += this.driftSpeed;
                this.currentAngle = this.baseAngle + Math.sin(this.time * this.angleSwaySpeed) * this.angleSway;

                // Reset if drifted too far off screen
                if (this.x < -this.width * 5 || this.x > canvas.width + this.width * 5) {
                     this.x = random(0, canvas.width); // Re-randomize x position
                     this.baseAngle = random(-0.05, 0.05); // And angle
                }
            }

            draw() {
                const currentOpacity = this.opacity * (0.6 + Math.sin(this.time * 0.5) * 0.4); // Shimmering opacity
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + Math.sin(this.currentAngle) * this.length, this.y + Math.cos(this.currentAngle) * this.length);
                ctx.strokeStyle = `rgba(255, 255, 220, ${currentOpacity})`; // Warm yellow light
                ctx.lineWidth = this.width;
                ctx.stroke();
            }
        }

        // Coral
        class Coral {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.baseColor = getRandomColor(coralPalette[type]);
                this.timeOffset = random(0, 1000); // For varied animation timing
                
                // Type-specific properties
                switch(this.type) {
                    case 'brain':
                        this.radius = random(20, 50);
                        this.segments = randomInt(5, 10);
                        break;
                    case 'staghorn':
                        this.branches = randomInt(3, 7);
                        this.branchLength = random(30, 80);
                        this.branchWidth = random(5, 15);
                        break;
                    case 'fan':
                        this.width = random(50, 120);
                        this.height = random(40, 100);
                        this.segments = randomInt(10, 20);
                        break;
                    case 'pillar':
                        this.pillars = randomInt(2, 5);
                        this.pillarHeight = random(50, 150);
                        this.pillarWidth = random(15, 30);
                        break;
                    case 'flower': // Anemone-like coral
                        this.petalCount = randomInt(8, 14); // More petals for lushness
                        this.petalLength = random(20, 40); // Renamed from petalRadius for clarity
                        this.coreRadius = random(6, 12);
                        this.swayFactor = random(0.005, 0.02); // Reduced sway factor
                        this.swaySpeed = 0.0005; // Reduced sway speed
                        this.swayAngle = 0;
                        break;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                switch(this.type) {
                    case 'brain':
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius, Math.PI, 0); // Half-circle base
                        ctx.fillStyle = this.baseColor;
                        ctx.fill();
                        // Add some texture/pattern
                        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < this.segments; i++) {
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (i / this.segments), Math.PI + random(0.1,0.3), -random(0.1,0.3), false);
                            ctx.stroke();
                        }
                        break;
                    case 'staghorn':
                        for (let i = 0; i < this.branches; i++) {
                            ctx.beginPath();
                            const angle = (Math.PI / this.branches) * i - Math.PI / 2 + random(-0.2, 0.2) - Math.PI/4; // Point upwards
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(angle) * this.branchLength, Math.sin(angle) * this.branchLength);
                            ctx.lineWidth = this.branchWidth - i*0.5; // Tapering
                            ctx.strokeStyle = this.baseColor;
                            ctx.lineCap = 'round';
                            ctx.stroke();
                        }
                        break;
                    case 'fan':
                        ctx.beginPath();
                        ctx.moveTo(0,0);
                        for(let i = 0; i <= this.segments; i++) {
                            const angle = (Math.PI / this.segments) * i - Math.PI/2 - Math.PI/4;
                            const x1 = (this.width/2) * Math.cos(angle);
                            const y1 = -this.height * Math.sin(Math.abs(angle)); 
                            ctx.lineTo(x1, y1);
                        }
                        ctx.closePath();
                        ctx.fillStyle = this.baseColor;
                        ctx.fill();
                        // Add some lines for texture
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.lineWidth = 1;
                         for(let i = 0; i <= this.segments; i+=2) {
                            const angle = (Math.PI / this.segments) * i - Math.PI/2 - Math.PI/4;
                            const x1 = (this.width/2) * Math.cos(angle);
                            const y1 = -this.height * Math.sin(Math.abs(angle)); 
                            ctx.beginPath();
                            ctx.moveTo(0,0);
                            ctx.lineTo(x1, y1);
                            ctx.stroke();
                        }
                        break;
                    case 'pillar':
                        for (let i = 0; i < this.pillars; i++) {
                            const xOffset = (i - (this.pillars - 1) / 2) * (this.pillarWidth * 1.2);
                            ctx.fillStyle = this.baseColor;
                            ctx.beginPath();
                            ctx.rect(xOffset - this.pillarWidth/2, -this.pillarHeight, this.pillarWidth, this.pillarHeight);
                            ctx.fill();
                            // Add cap
                            ctx.beginPath();
                            ctx.arc(xOffset, -this.pillarHeight, this.pillarWidth/2, Math.PI, 0);
                            ctx.fill();
                        }
                        break;
                    case 'flower': // Anemone-like coral
                        this.swayAngle = Math.sin(Date.now() * this.swaySpeed + this.x * 0.1 + this.timeOffset) * this.swayFactor;
                        ctx.fillStyle = this.baseColor;
                        for (let i = 0; i < this.petalCount; i++) {
                            const angle = (Math.PI * 2 / this.petalCount) * i + this.swayAngle + Math.sin(Date.now() * this.swaySpeed * 0.5 + i*0.5 + this.timeOffset) * this.swayFactor * 2; // Add individual petal flutter
                            const currentPetalLength = this.petalLength * (0.8 + Math.sin(Date.now() * this.swaySpeed * 0.7 + i*0.8 + this.timeOffset) * 0.2); // Pulsing length

                            const x1 = Math.cos(angle) * this.coreRadius;
                            const y1 = Math.sin(angle) * this.coreRadius;
                            const x2 = Math.cos(angle) * (this.coreRadius + currentPetalLength);
                            const y2 = Math.sin(angle) * (this.coreRadius + currentPetalLength);
                            
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            // More organic petal shape
                            ctx.quadraticCurveTo(
                                Math.cos(angle + 0.1) * (this.coreRadius + currentPetalLength * 0.6),
                                Math.sin(angle + 0.1) * (this.coreRadius + currentPetalLength * 0.6),
                                x2, y2
                            );
                            ctx.quadraticCurveTo(
                                Math.cos(angle - 0.1) * (this.coreRadius + currentPetalLength * 0.6),
                                Math.sin(angle - 0.1) * (this.coreRadius + currentPetalLength * 0.6),
                                x1, y1
                            );
                            ctx.fill();
                        }
                        // Draw a slightly darker core
                        ctx.beginPath();
                        ctx.arc(0,0, this.coreRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(0,0,0,0.15)`;
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }

        // Fish
        class Fish {
            constructor(species) {
                this.species = species; 
                this.x = random(0, canvas.width);
                this.y = random(canvas.height * 0.1, canvas.height * 0.8); 
                this.size = this.species === 'small_schooling' ? random(5, 10) : random(10, 20);
                this.color1 = getRandomColor(fishPalette);
                this.color2 = getRandomColor(fishPalette.filter(c => c !== this.color1)); 
                this.speed = random(0.5, 2);
                this.maxSpeed = this.speed * 1.2; // Max speed for fleeing etc.
                this.angle = random(0, Math.PI * 2);
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.time = random(0,100); 

                // Schooling behavior
                this.schoolId = (this.species === 'small_schooling' && Math.random() < 0.7) ? Math.floor(random(0, fishCount / 10)) : null;
                this.perceptionRadius = 50;
                this.separationDistance = 20; // How close before strongly separating
                this.maxForce = 0.05; 
            }
            
            applyForce(force) {
                this.vx += force.x;
                this.vy += force.y;
            }

            // Boids-like behaviors
            separation(others) {
                let steer = {x:0, y:0};
                let count = 0;
                for (let other of others) {
                    let d = Math.hypot(this.x - other.x, this.y - other.y);
                    if (d > 0 && d < this.separationDistance) {
                        let diff = {x: this.x - other.x, y: this.y - other.y};
                        diff.x /= d; // Normalize
                        diff.y /= d;
                        diff.x /= d; // Weight by distance (stronger repulsion when closer)
                        diff.y /= d;
                        steer.x += diff.x;
                        steer.y += diff.y;
                        count++;
                    }
                }
                if (count > 0) {
                    steer.x /= count;
                    steer.y /= count;
                }
                const mag = Math.hypot(steer.x, steer.y);
                if (mag > 0) {
                    steer.x = (steer.x / mag) * this.maxSpeed;
                    steer.y = (steer.y / mag) * this.maxSpeed;
                    steer.x -= this.vx;
                    steer.y -= this.vy;
                    const steerMag = Math.hypot(steer.x, steer.y);
                    if (steerMag > this.maxForce) {
                        steer.x = (steer.x / steerMag) * this.maxForce;
                        steer.y = (steer.y / steerMag) * this.maxForce;
                    }
                }
                return steer;
            }

            align(others) {
                let sum = {x:0, y:0};
                let count = 0;
                for (let other of others) {
                    let d = Math.hypot(this.x - other.x, this.y - other.y);
                    if (d > 0 && d < this.perceptionRadius) {
                        sum.x += other.vx;
                        sum.y += other.vy;
                        count++;
                    }
                }
                if (count > 0) {
                    sum.x /= count;
                    sum.y /= count;
                    const mag = Math.hypot(sum.x, sum.y);
                    if (mag > 0) {
                        sum.x = (sum.x / mag) * this.maxSpeed;
                        sum.y = (sum.y / mag) * this.maxSpeed;
                    }
                    let steer = {x: sum.x - this.vx, y: sum.y - this.vy};
                    const steerMag = Math.hypot(steer.x, steer.y);
                     if (steerMag > this.maxForce) {
                        steer.x = (steer.x / steerMag) * this.maxForce;
                        steer.y = (steer.y / steerMag) * this.maxForce;
                    }
                    return steer;
                }
                return {x:0, y:0};
            }

            cohesion(others) {
                let sum = {x:0, y:0};
                let count = 0;
                for (let other of others) {
                    let d = Math.hypot(this.x - other.x, this.y - other.y);
                    if (d > 0 && d < this.perceptionRadius) {
                        sum.x += other.x;
                        sum.y += other.y;
                        count++;
                    }
                }
                if (count > 0) {
                    sum.x /= count;
                    sum.y /= count;
                    let desired = {x: sum.x - this.x, y: sum.y - this.y};
                    const mag = Math.hypot(desired.x, desired.y);
                    if (mag > 0) {
                        desired.x = (desired.x / mag) * this.maxSpeed;
                        desired.y = (desired.y / mag) * this.maxSpeed;
                    }
                    let steer = {x: desired.x - this.vx, y: desired.y - this.vy};
                    const steerMag = Math.hypot(steer.x, steer.y);
                     if (steerMag > this.maxForce) {
                        steer.x = (steer.x / steerMag) * this.maxForce;
                        steer.y = (steer.y / steerMag) * this.maxForce;
                    }
                    return steer;
                }
                return {x:0, y:0};
            }


            update(allFish) {
                this.time += 0.1;

                if (this.schoolId !== null) {
                    const schoolMates = allFish.filter(f => f.schoolId === this.schoolId && f !== this);
                    if (schoolMates.length > 0) {
                        let sep = this.separation(schoolMates);
                        let ali = this.align(schoolMates);
                        let coh = this.cohesion(schoolMates);

                        // Apply weights
                        sep.x *= 1.8; sep.y *= 1.8; 
                        ali.x *= 1.0; ali.y *= 1.0;
                        coh.x *= 1.0; coh.y *= 1.0;

                        this.applyForce(sep);
                        this.applyForce(ali);
                        this.applyForce(coh);
                    }
                } else { 
                    if (Math.random() < 0.03) { // Solitary fish less frequent random turns
                        let desiredAngle = this.angle + random(-0.6, 0.6);
                        let desiredVel = { x: Math.cos(desiredAngle) * this.speed, y: Math.sin(desiredAngle) * this.speed };
                        let steer = { x: desiredVel.x - this.vx, y: desiredVel.y - this.vy };
                        const steerMag = Math.hypot(steer.x, steer.y);
                        if (steerMag > this.maxForce * 0.5) { // Weaker steering for random turns
                           steer.x = (steer.x / steerMag) * this.maxForce * 0.5;
                           steer.y = (steer.y / steerMag) * this.maxForce * 0.5;
                        }
                        this.applyForce(steer);
                    }
                }

                // Mouse interaction: gentle push
                if (mouse.x !== undefined && mouse.y !== undefined) {
                    const dxMouse = this.x - mouse.x;
                    const dyMouse = this.y - mouse.y;
                    const distMouse = Math.hypot(dxMouse, dyMouse);
                    if (distMouse < 60) { // Increased interaction radius
                        const forceMagnitude = (60 - distMouse) / 60 * 0.8; // Stronger push
                        let force = {
                            x: (dxMouse / distMouse) * forceMagnitude,
                            y: (dyMouse / distMouse) * forceMagnitude
                        };
                        this.applyForce(force);
                    }
                }
                
                // Limit speed
                const currentSpeed = Math.hypot(this.vx, this.vy);
                if (currentSpeed > this.maxSpeed) {
                    this.vx = (this.vx / currentSpeed) * this.maxSpeed;
                    this.vy = (this.vy / currentSpeed) * this.maxSpeed;
                } else if (currentSpeed < this.speed * 0.5 && this.schoolId === null) { // Min speed for solitary
                    this.vx = (this.vx / currentSpeed) * this.speed * 0.5;
                    this.vy = (this.vy / currentSpeed) * this.speed * 0.5;
                }


                this.x += this.vx;
                this.y += this.vy;

                // Boundary checks 
                const padding = this.size * 3; 
                const turnForce = 0.1; // Force to turn fish away from boundaries

                if (this.x < padding) { this.vx += turnForce; }
                if (this.x > canvas.width - padding) { this.vx -= turnForce; }
                if (this.y < padding) { this.vy += turnForce; }
                if (this.y > canvas.height - 30 - padding) { // Avoid seabed (30 is approx seabed height)
                    this.vy -= turnForce; 
                    if (this.y > canvas.height - 30 - this.size) this.y = canvas.height - 30 - this.size; // Prevent going into seabed
                }

                // Fallback wrapping if they somehow escape hard
                if (this.x < -padding*2) this.x = canvas.width + padding;
                if (this.x > canvas.width + padding*2) this.x = -padding;
                if (this.y < -padding*2) this.y = canvas.height + padding;
                if (this.y > canvas.height + padding*2) this.y = -padding;


                // Update angle based on velocity for drawing
                if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) { // Only update if moving
                    this.angle = Math.atan2(this.vy, this.vx);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size / 2, 0, 0, Math.PI * 2);
                
                const gradient = ctx.createLinearGradient(-this.size, 0, this.size, 0);
                gradient.addColorStop(0, this.color1);
                gradient.addColorStop(1, this.color2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Tail fin
                const tailSway = Math.sin(this.time * 0.8) * (this.size / 3.5); 
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.7, 0); // Slightly more attached to body
                ctx.lineTo(-this.size * 1.3, -this.size / 2.5 + tailSway); // Wider, more dynamic tail
                ctx.lineTo(-this.size * 1.3, this.size / 2.5 + tailSway);
                ctx.closePath();
                ctx.fillStyle = this.color2;
                ctx.fill();

                // Dorsal fin
                ctx.beginPath();
                ctx.moveTo(this.size * 0.4, -this.size * 0.05);
                ctx.quadraticCurveTo(this.size * 0.2, -this.size * 0.7, -this.size * 0.3, -this.size*0.1);
                ctx.fillStyle = this.color1;
                ctx.fill();

                // Eye
                ctx.beginPath();
                ctx.arc(this.size * 0.65, 0, this.size / 7, 0, Math.PI * 2); // Slightly larger eye
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.size * 0.7, 0, this.size / 14, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();

                ctx.restore();
            }
        }

        // Plant (Seaweed/Anemone)
        class Plant {
            constructor(x, y) {
                this.x = x;
                this.y = y; 
                this.segments = randomInt(5, 10);
                this.segmentLength = random(10, 20);
                this.maxHeight = this.segments * this.segmentLength * 0.8; 
                this.color = getRandomColor(plantPalette);
                this.lineWidth = random(2, 5);
                this.swaySpeed = random(0.0005, 0.0015); // Slightly slower on average
                this.swayAmplitude = random(0.05, 0.25); // Reduced amplitude
                this.timeOffset = random(0, 1000); 
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                let currentX = this.x;
                let currentY = this.y;

                for (let i = 0; i < this.segments; i++) {
                    const sway = Math.sin(Date.now() * this.swaySpeed + this.timeOffset + i * 0.3) * this.swayAmplitude * (i+1) * 0.5; // Reduced overall sway effect
                    const angle = -Math.PI / 2 + sway; 
                    const nextX = currentX + Math.cos(angle) * this.segmentLength;
                    const nextY = currentY + Math.sin(angle) * this.segmentLength;
                    ctx.lineTo(nextX, nextY);
                    currentX = nextX;
                    currentY = nextY;
                }
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        // Bubble
        class Bubble {
            constructor() {
                this.x = random(0, canvas.width);
                this.y = canvas.height + random(10, 50); 
                this.radius = random(1, 4); // Slightly smaller max size
                this.speedY = random(0.3, 1.5); // Slower min speed
                this.speedX = random(-0.15, 0.15); 
                this.opacity = random(0.2, 0.7);
            }

            update() {
                this.y -= this.speedY;
                this.x += this.speedX;
                if (this.y < -this.radius * 2) { 
                    this.y = canvas.height + random(10, 50);
                    this.x = random(0, canvas.width);
                    this.opacity = random(0.2, 0.7); // Reset opacity too
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 225, 255, ${this.opacity})`;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x - this.radius*0.3, this.y - this.radius*0.3, this.radius*0.3, 0, Math.PI*2);
                ctx.fillStyle = `rgba(255,255,255, ${this.opacity * 0.9})`; // Brighter highlight
                ctx.fill();
            }
        }
        
        // Particle (Plankton/Detritus)
        class Particle {
            constructor() {
                this.x = random(0, canvas.width);
                this.y = random(0, canvas.height);
                this.size = random(0.5, 1.2); // Smaller max size
                this.color = `rgba(200, 220, 255, ${random(0.15, 0.5)})`; 
                this.vx = random(-0.05, 0.05); 
                this.vy = random(-0.05, 0.05);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }


        // --- Initialization ---
        function init() {
            canvas.width = window.innerWidth * 0.9; 
            canvas.height = window.innerHeight * 0.75; 
            if (canvas.width < 400) canvas.width = 400; 
            if (canvas.height < 300) canvas.height = 300; 

            fishArray = [];
            coralArray = [];
            plantArray = [];
            bubbleArray = [];
            particleArray = [];
            lightRayArray = [];
            rippleEffects = [];

            for (let i = 0; i < 12; i++) { // Reduced number of rays for performance, more dynamic ones
                lightRayArray.push(new LightRay());
            }

            const seabedY = canvas.height - 10; 
            const coralTypes = Object.keys(coralPalette);
            for (let i = 0; i < randomInt(8, 15); i++) { // Slightly fewer corals
                const type = coralTypes[randomInt(0, coralTypes.length - 1)];
                let coralX = random(canvas.width * 0.05, canvas.width * 0.95); // Avoid edges
                let coralY = seabedY - random(0, 30); 
                
                let tempCoral = new Coral(coralX, coralY, type); 
                if (type === 'pillar') coralY = seabedY; 
                else if (type === 'staghorn') coralY = seabedY - tempCoral.branchLength * 0.05; 
                else if (type === 'fan') coralY = seabedY - tempCoral.height * 0.05;

                coralArray.push(new Coral(coralX, coralY, type));
            }
            coralArray.sort((a, b) => a.y - b.y);

            for (let i = 0; i < randomInt(12, 20); i++) { // Slightly fewer plants
                let plantX = random(canvas.width * 0.05, canvas.width * 0.95);
                let plantY = seabedY - random(-2, 10); 
                plantArray.push(new Plant(plantX, plantY));
            }
            plantArray.sort((a,b) => a.y - b.y);

            document.getElementById('fishCountDisplay').textContent = fishCount;
            for (let i = 0; i < fishCount; i++) {
                const species = Math.random() < 0.6 ? 'small_schooling' : 'medium_solitary';
                fishArray.push(new Fish(species));
            }

            for (let i = 0; i < 25; i++) { 
                bubbleArray.push(new Bubble());
            }
            
            for (let i = 0; i < 80; i++) { 
                particleArray.push(new Particle());
            }
        }

        // --- Animation Loop ---
        function animate() {
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#00407A'); // Slightly darker top
            bgGradient.addColorStop(0.5, '#002E5D'); 
            bgGradient.addColorStop(1, '#001f3f'); 
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            lightRayArray.forEach(ray => {
                ray.update();
                ray.draw();
            });
            
            drawCaustics();

            ctx.fillStyle = '#A0702D'; // Slightly richer sand color: SaddleBrown-ish
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            const waveAmplitude = 12;
            const waveLength = 250; // Longer waves
            const timeFactor = Date.now() * 0.00005; // Slower wave movement
            for(let x = 0; x <= canvas.width; x+=15) { // Smoother curve
                const yOffset = Math.sin(x / waveLength * Math.PI * 2 + timeFactor + Math.sin(x/ (waveLength/3) * Math.PI*2 + timeFactor*2)*0.3 ) * waveAmplitude; // Compound sine for more natural waves
                ctx.lineTo(x, canvas.height - 30 + yOffset);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            // Add subtle texture to seabed
            for(let x = 0; x <= canvas.width; x+=30) {
                 const yOffset = Math.sin(x / waveLength * Math.PI * 2 + timeFactor + Math.sin(x/ (waveLength/3) * Math.PI*2 + timeFactor*2)*0.3 ) * waveAmplitude;
                 const textureAlpha = random(0.02, 0.08);
                 ctx.fillStyle = `rgba(0,0,0,${textureAlpha})`;
                 ctx.beginPath();
                 ctx.arc(x + random(-10,10), canvas.height - 30 + yOffset + random(-3,3), random(1,3), 0, Math.PI*2);
                 ctx.fill();
            }


            particleArray.forEach(p => {
                p.update();
                p.draw();
            });

            coralArray.forEach(coral => coral.draw());
            plantArray.forEach(plant => plant.draw());
            
            fishArray.forEach(fish => {
                fish.update(fishArray); 
                fish.draw();
            });

            bubbleArray.forEach(bubble => {
                bubble.update();
                bubble.draw();
            });

            rippleEffects = rippleEffects.filter(r => r.opacity > 0);
            rippleEffects.forEach(ripple => {
                ripple.update();
                ripple.draw();
            });
            
            // Reset click flag after processing
            if (mouse.clicked) mouse.clicked = false;

            requestAnimationFrame(animate);
        }
        
        let causticTime = 0;
        function drawCaustics() {
            causticTime += 0.008; // Slower caustic movement
            const seabedTop = canvas.height - 45; 
            const causticHeight = 70; // Slightly larger area

            for (let y = 0; y < causticHeight; y += 6) { // Slightly larger steps
                for (let x = 0; x < canvas.width; x += 60) { // Slightly larger steps
                    const brightness = (Math.sin(x * 0.015 + causticTime + y * 0.04) + Math.cos(y*0.025 + causticTime*0.6 + x*0.008)) * 0.5 + 0.5; 
                    const alpha = brightness * 0.04 * (1 - y/causticHeight); 
                    if (alpha > 0.005) { // Lower threshold for more subtle caustics
                        ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`; 
                        ctx.beginPath();
                        const offsetX = Math.sin(causticTime * 1.2 + x*0.08) * 12;
                        const offsetY = Math.cos(causticTime*0.8 + y*0.08) * 6;
                        ctx.ellipse(x + offsetX, seabedTop + y + offsetY, 35 + brightness * 25, 4 + brightness * 3, Math.sin(x+y+causticTime*1.1)*0.25, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }
        }

        const fishSlider = document.getElementById('fishSlider');
        fishSlider.addEventListener('input', (e) => {
            fishCount = parseInt(e.target.value);
            document.getElementById('fishCountDisplay').textContent = fishCount;
        });
        fishSlider.addEventListener('change', (e) => { 
            fishCount = parseInt(e.target.value);
            init();
        });

        document.getElementById('resetSimButton').addEventListener('click', () => {
            init(); 
        });
        
        window.addEventListener('resize', () => {
            init(); 
        });

        init();
        animate();

    </script>
</body>
</html>
